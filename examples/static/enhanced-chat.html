<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Enhanced WebSocket Chat - Full Featured</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            height: 100vh;
            display: flex;
            justify-content: center;
            align-items: center;
        }

        .chat-container {
            width: 95%;
            max-width: 1200px;
            height: 95vh;
            background: white;
            border-radius: 10px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, 0.3);
            display: flex;
            flex-direction: column;
            overflow: hidden;
        }

        .chat-header {
            background: #4f46e5;
            color: white;
            padding: 1rem;
            text-align: center;
            font-size: 1.2rem;
            font-weight: bold;
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .header-controls {
            display: flex;
            gap: 0.5rem;
            align-items: center;
        }

        .btn {
            padding: 0.5rem 1rem;
            border: none;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: all 0.2s;
        }

        .btn-primary {
            background: #3b82f6;
            color: white;
        }

        .btn-primary:hover {
            background: #2563eb;
        }

        .btn-success {
            background: #10b981;
            color: white;
        }

        .btn-success:hover {
            background: #059669;
        }

        .btn-danger {
            background: #ef4444;
            color: white;
        }

        .btn-danger:hover {
            background: #dc2626;
        }

        .btn-warning {
            background: #f59e0b;
            color: white;
        }

        .btn-warning:hover {
            background: #d97706;
        }

        .connection-status {
            padding: 0.5rem;
            text-align: center;
            font-size: 0.9rem;
            background: #f3f4f6;
            border-bottom: 1px solid #e5e7eb;
        }

        .connection-status.connected {
            background: #d1fae5;
            color: #065f46;
        }

        .connection-status.disconnected {
            background: #fee2e2;
            color: #991b1b;
        }

        .main-content {
            display: flex;
            flex: 1;
            overflow: hidden;
        }

        .sidebar {
            width: 250px;
            background: #f8fafc;
            border-right: 1px solid #e5e7eb;
            display: flex;
            flex-direction: column;
        }

        .user-setup {
            padding: 1rem;
            text-align: center;
        }

        .user-setup input {
            width: 100%;
            padding: 0.75rem;
            margin-bottom: 1rem;
            border: 1px solid #d1d5db;
            border-radius: 5px;
        }

        .rooms-section {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
        }

        .rooms-section h3 {
            margin-bottom: 0.5rem;
            color: #374151;
        }

        .room-list {
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .room-btn {
            padding: 0.75rem;
            background: #e5e7eb;
            border-radius: 5px;
            cursor: pointer;
            transition: all 0.2s;
            text-align: center;
        }

        .room-btn:hover {
            background: #d1d5db;
        }

        .room-btn.active {
            background: #4f46e5;
            color: white;
        }

        .online-users {
            display: flex;
            flex-direction: column;
            gap: 0.25rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .user-item {
            padding: 0.5rem;
            background: #f3f4f6;
            border-radius: 5px;
            font-size: 0.875rem;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .user-status {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #10b981;
            flex-shrink: 0;
        }

        .user-item.self {
            background: #ddd6fe;
            border: 1px solid #8b5cf6;
        }

        /* Toast Notifications */
        .toast-container {
            position: fixed;
            top: 20px;
            right: 20px;
            z-index: 1000;
            max-width: 350px;
        }

        .toast {
            background: white;
            border-radius: 8px;
            box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
            margin-bottom: 10px;
            padding: 15px 20px;
            border-left: 4px solid #4f46e5;
            animation: slideIn 0.3s ease-out;
            position: relative;
        }

        .toast.call-invite {
            border-left-color: #10b981;
        }

        .toast.error {
            border-left-color: #ef4444;
        }

        .toast.warning {
            border-left-color: #f59e0b;
        }

        .toast-header {
            font-weight: bold;
            margin-bottom: 5px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .toast-body {
            color: #6b7280;
            margin-bottom: 10px;
        }

        .toast-actions {
            display: flex;
            gap: 8px;
        }

        .toast-btn {
            padding: 6px 12px;
            border: none;
            border-radius: 4px;
            cursor: pointer;
            font-size: 0.875rem;
            font-weight: 500;
        }

        .toast-btn.accept {
            background: #10b981;
            color: white;
        }

        .toast-btn.decline {
            background: #ef4444;
            color: white;
        }

        .toast-btn.dismiss {
            background: #e5e7eb;
            color: #374151;
        }

        .toast-close {
            position: absolute;
            top: 10px;
            right: 15px;
            background: none;
            border: none;
            font-size: 18px;
            cursor: pointer;
            color: #9ca3af;
        }

        @keyframes slideIn {
            from {
                transform: translateX(100%);
                opacity: 0;
            }

            to {
                transform: translateX(0);
                opacity: 1;
            }
        }

        @keyframes slideOut {
            from {
                transform: translateX(0);
                opacity: 1;
            }

            to {
                transform: translateX(100%);
                opacity: 0;
            }
        }

        .toast.call-invitation {
            border-left: 4px solid #22c55e;
            background: linear-gradient(135deg, #dcfce7, #bbf7d0);
            box-shadow: 0 8px 25px rgba(34, 197, 94, 0.2);
        }

        .toast.call-invitation .toast-header {
            background: #22c55e;
            color: white;
            font-weight: bold;
        }

        .chat-area {
            flex: 1;
            display: flex;
            flex-direction: column;
        }

        .messages-container {
            flex: 1;
            padding: 1rem;
            overflow-y: auto;
            display: flex;
            flex-direction: column;
            gap: 0.5rem;
        }

        .message {
            max-width: 70%;
            padding: 0.75rem;
            border-radius: 10px;
            background: #f3f4f6;
            color: #374151;
        }

        .message.own {
            align-self: flex-end;
            background: #4f46e5;
            color: white;
        }

        .message.other {
            align-self: flex-start;
            background: #f3f4f6;
            color: #374151;
        }

        .message.system {
            background: #fef3c7;
            color: #92400e;
            text-align: center;
            max-width: 100%;
            font-style: italic;
        }

        .message .sender {
            font-weight: bold;
            font-size: 0.8rem;
            margin-bottom: 0.25rem;
        }

        .message .content {
            font-size: 0.9rem;
            line-height: 1.4;
        }

        .message .time {
            font-size: 0.7rem;
            opacity: 0.7;
            margin-top: 0.25rem;
        }

        .media-preview {
            margin: 0.5rem 0;
            border-radius: 5px;
            overflow: hidden;
        }

        .media-preview img {
            max-width: 100%;
            height: auto;
        }

        .media-preview audio,
        .media-preview video {
            max-width: 100%;
        }

        .file-attachment {
            padding: 0.5rem;
            background: rgba(255, 255, 255, 0.1);
            border-radius: 5px;
            margin: 0.5rem 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 0.5rem;
        }

        .typing-indicator {
            padding: 0.5rem 1rem;
            background: #f3f4f6;
            border-top: 1px solid #e5e7eb;
            font-style: italic;
            color: #6b7280;
            font-size: 0.8rem;
            min-height: 2rem;
        }

        .input-container {
            padding: 1rem;
            background: #f8fafc;
            border-top: 1px solid #e5e7eb;
        }

        .input-row {
            display: flex;
            gap: 0.5rem;
            align-items: center;
            margin-bottom: 0.5rem;
        }

        .message-input {
            flex: 1;
            padding: 0.75rem;
            border: 1px solid #d1d5db;
            border-radius: 25px;
            font-size: 0.9rem;
            outline: none;
        }

        .message-input:focus {
            border-color: #4f46e5;
        }

        .media-controls {
            display: flex;
            gap: 0.5rem;
            margin-bottom: 0.5rem;
        }

        .file-input {
            display: none;
        }

        .preview-container {
            margin-bottom: 0.5rem;
            max-height: 200px;
            overflow-y: auto;
        }

        .preview-item {
            display: flex;
            align-items: center;
            gap: 0.5rem;
            padding: 0.5rem;
            background: #e5e7eb;
            border-radius: 5px;
            margin-bottom: 0.25rem;
        }

        .preview-item .remove-btn {
            background: #ef4444;
            color: white;
            border: none;
            border-radius: 50%;
            width: 20px;
            height: 20px;
            cursor: pointer;
            font-size: 0.7rem;
        }

        .video-call-container {
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(0, 0, 0, 0.95);
            z-index: 1000;
            display: none;
            flex-direction: row;
        }

        .video-main-area {
            flex: 1;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .main-video {
            width: 90%;
            max-width: 800px;
            height: 60vh;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
            position: relative;
        }

        .main-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .main-video .user-label {
            position: absolute;
            bottom: 15px;
            left: 15px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.5rem 1rem;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 500;
        }

        .video-sidebar {
            width: 250px;
            background: rgba(0, 0, 0, 0.7);
            border-left: 1px solid rgba(255, 255, 255, 0.1);
            display: flex;
            flex-direction: column;
            padding: 20px;
        }

        .video-sidebar h3 {
            color: white;
            margin-bottom: 15px;
            font-size: 1.1rem;
        }

        .participant-videos {
            flex: 1;
            overflow-y: auto;
        }

        .participant-video {
            width: 100%;
            height: 120px;
            background: #000;
            border-radius: 8px;
            overflow: hidden;
            position: relative;
            margin-bottom: 10px;
        }

        .participant-video video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .participant-video .user-label {
            position: absolute;
            bottom: 5px;
            left: 5px;
            color: white;
            background: rgba(0, 0, 0, 0.8);
            padding: 0.25rem 0.5rem;
            border-radius: 4px;
            font-size: 0.75rem;
        }

        .video-grid {
            display: none;
            /* Hide old grid layout */
        }

        .video-item {
            position: relative;
            background: #000;
            border-radius: 10px;
            overflow: hidden;
        }

        .video-item video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        .video-item .user-label {
            position: absolute;
            bottom: 10px;
            left: 10px;
            color: white;
            background: rgba(0, 0, 0, 0.7);
            padding: 0.25rem 0.5rem;
            border-radius: 5px;
            font-size: 0.8rem;
        }

        .call-controls {
            margin-top: 2rem;
            display: flex;
            gap: 1rem;
        }

        .recording-indicator {
            position: fixed;
            top: 20px;
            right: 20px;
            background: #ef4444;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            display: none;
            animation: pulse 2s infinite;
        }

        @keyframes pulse {
            0% {
                opacity: 1;
            }

            50% {
                opacity: 0.5;
            }

            100% {
                opacity: 1;
            }
        }

        .screen-share-indicator {
            position: fixed;
            top: 60px;
            right: 20px;
            background: #10b981;
            color: white;
            padding: 0.5rem 1rem;
            border-radius: 20px;
            font-size: 0.8rem;
            display: none;
        }

        @media (max-width: 768px) {
            .main-content {
                flex-direction: column;
            }

            .sidebar {
                width: 100%;
                height: auto;
                max-height: 30%;
            }

            .message {
                max-width: 85%;
            }

            .video-grid {
                grid-template-columns: 1fr;
                max-width: 95%;
            }

            .media-controls {
                flex-wrap: wrap;
            }
        }
    </style>
</head>

<body>
    <div class="chat-container">
        <div class="chat-header">
            <span>üöÄ Enhanced WebSocket Chat</span>
            <div class="header-controls">
                <button class="btn btn-success" onclick="startAudioCall()" id="audioCallBtn">üìû Audio Call</button>
                <button class="btn btn-success" onclick="startVideoCall()" id="videoCallBtn">üìπ Video Call</button>
            </div>
        </div>

        <div class="connection-status" id="connectionStatus">
            Disconnected
        </div>

        <div class="main-content">
            <div class="sidebar">
                <div class="user-setup" id="userSetup">
                    <input type="text" id="usernameInput" placeholder="Enter your username" maxlength="20">
                    <button class="btn btn-primary" onclick="connect()">Connect</button>
                </div>

                <div class="rooms-section" id="roomsSection" style="display: none;">
                    <h3>Rooms:</h3>
                    <div class="room-list">
                        <span class="room-btn" onclick="joinRoom('public:lobby', this)">üè† Lobby</span>
                        <span class="room-btn" onclick="joinRoom('public:random', this)">üé≤ Random</span>
                        <span class="room-btn" onclick="joinRoom('public:help', this)">‚ùì Help</span>
                        <span class="room-btn" onclick="joinRoom('public:media', this)">üé¨ Media Room</span>
                    </div>
                    <h4 style="margin-top: 1rem; margin-bottom: 0.5rem;">Online Users:</h4>
                    <div id="onlineUsers" class="online-users"></div>
                </div>
            </div>

            <div class="chat-area">
                <div class="messages-container" id="messagesContainer">
                    <div class="message system">
                        <div class="content">Welcome to the Enhanced WebSocket Chat! Upload files, share audio/video,
                            start calls, and more!</div>
                    </div>
                </div>

                <div class="typing-indicator" id="typingIndicator"></div>

                <div class="input-container">
                    <div class="media-controls">
                        <button class="btn btn-primary" onclick="document.getElementById('fileInput').click()">üìé
                            File</button>
                        <button class="btn btn-primary" onclick="capturePhoto()">üì∑ Photo</button>
                        <button class="btn btn-primary" onclick="toggleAudioRecording()" id="audioRecordBtn">üé§
                            Audio</button>
                        <button class="btn btn-primary" onclick="toggleVideoRecording()" id="videoRecordBtn">üìπ
                            Video</button>
                        <button class="btn btn-primary" onclick="shareLocation()">üìç Location</button>
                        <button class="btn btn-warning" onclick="shareScreen()">üñ•Ô∏è Screen Share</button>
                        <button class="btn btn-warning" onclick="recordScreen()" id="screenRecordBtn">‚è∫Ô∏è Record
                            Screen</button>
                    </div>

                    <div class="preview-container" id="previewContainer"></div>

                    <div class="input-row">
                        <input type="text" id="messageInput" class="message-input" placeholder="Type a message..."
                            disabled>
                        <button id="sendBtn" class="btn btn-primary" onclick="sendMessage()" disabled>Send</button>
                    </div>

                    <!-- Hidden file inputs -->
                    <input type="file" id="fileInput" class="file-input" multiple
                        accept="image/*,video/*,audio/*,.pdf,.doc,.docx,.txt,.zip"
                        onchange="handleFileSelection(event)">
                    <input type="file" id="cameraInput" class="file-input" accept="image/*" capture="camera"
                        onchange="handleFileSelection(event)">
                    <video id="cameraPreview" style="display: none;" autoplay></video>
                </div>
            </div>
        </div>
    </div>

    <!-- Video Call Container -->
    <div class="video-call-container" id="videoCallContainer">
        <div class="video-main-area">
            <div class="main-video" id="mainVideo">
                <video id="localVideo" autoplay muted></video>
                <div class="user-label">You</div>
            </div>
            <div class="call-controls">
                <button class="btn btn-warning" onclick="toggleMute()" id="muteBtn">üîá Mute</button>
                <button class="btn btn-warning" onclick="toggleCamera()" id="cameraBtn">üìπ Camera</button>
                <button class="btn btn-primary" onclick="toggleScreenShare()" id="shareBtn">üñ•Ô∏è Share</button>
                <button class="btn btn-danger" onclick="endCall()">üìû End Call</button>
            </div>
        </div>

        <div class="video-sidebar">
            <h3>Participants</h3>
            <div class="participant-videos" id="participantVideos">
                <!-- Participant videos will be added here -->
            </div>
        </div>
    </div>

    <!-- Recording Indicator -->
    <div class="recording-indicator" id="recordingIndicator">
        üî¥ Recording...
    </div>

    <!-- Screen Share Indicator -->
    <div class="screen-share-indicator" id="screenShareIndicator">
        üñ•Ô∏è Sharing Screen
    </div>

    <!-- Toast Notifications Container -->
    <div class="toast-container" id="toastContainer">
    </div>

    <script>
        // WebSocket and Chat Variables
        let ws = null;
        let currentUser = null;
        let currentRoom = 'public:lobby';
        let isTyping = false;
        let typingTimeout = null;
        let reconnectAttempts = 0;
        const maxReconnectAttempts = 5;

        // Media Variables
        let pendingFiles = [];
        let audioRecorder = null;
        let videoRecorder = null;
        let recordedChunks = [];
        let isRecordingAudio = false;
        let isRecordingVideo = false;
        let cameraStream = null;

        // WebRTC Variables
        let localStream = null;
        let remoteStreams = new Map();
        let peerConnections = new Map();
        let isInCall = false;
        let isMuted = false;
        let isCameraOff = false;
        let isScreenSharing = false;
        let screenStream = null;
        let mediaRecorder = null;
        let isRecordingCall = false;

        // DOM elements
        const connectionStatus = document.getElementById('connectionStatus');
        const userSetup = document.getElementById('userSetup');
        const roomsSection = document.getElementById('roomsSection');
        const messagesContainer = document.getElementById('messagesContainer');
        const typingIndicator = document.getElementById('typingIndicator');
        const usernameInput = document.getElementById('usernameInput');
        const messageInput = document.getElementById('messageInput');
        const sendBtn = document.getElementById('sendBtn');
        const previewContainer = document.getElementById('previewContainer');
        const videoCallContainer = document.getElementById('videoCallContainer');
        const videoGrid = document.getElementById('videoGrid');
        const localVideo = document.getElementById('localVideo');
        const toastContainer = document.getElementById('toastContainer');
        const participantVideos = document.getElementById('participantVideos');
        const mainVideo = document.getElementById('mainVideo');

        // Call Invitation Functions
        function showCallInvitation(username, userId, callType = 'video') {
            const callIcon = callType === 'audio' ? 'üìû' : 'üìπ';
            const callTypeText = callType === 'audio' ? 'Audio' : 'Video';

            const invitationToast = document.createElement('div');
            invitationToast.className = 'toast call-invitation';
            invitationToast.innerHTML = `
                <div class="toast-header">
                    <strong>${callIcon} Incoming ${callTypeText} Call</strong>
                    <button class="toast-close" onclick="this.parentElement.parentElement.remove()">&times;</button>
                </div>
                <div class="toast-body">
                    <p><strong>${username}</strong> is inviting you to a ${callTypeText.toLowerCase()} call</p>
                    <div style="display: flex; gap: 10px; margin-top: 10px;">
                        <button class="btn btn-success" onclick="acceptCall('${userId}', '${username}', '${callType}'); this.parentElement.parentElement.parentElement.remove();">
                            ${callIcon} Accept
                        </button>
                        <button class="btn btn-danger" onclick="declineCall('${userId}', '${username}', '${callType}'); this.parentElement.parentElement.parentElement.remove();">
                            ‚ùå Decline
                        </button>
                    </div>
                </div>
            `;

            document.getElementById('toastContainer').appendChild(invitationToast);

            // Auto-remove after 30 seconds
            setTimeout(() => {
                if (invitationToast.parentElement) {
                    invitationToast.remove();
                }
            }, 30000);
        }

        function acceptCall(userId, username, callType = 'video') {
            // Start own call based on the call type
            if (callType === 'audio') {
                startAudioCall();
            } else {
                startVideoCall();
            }

            // Send acceptance message
            sendWebSocketMessage({
                type: 'call_answer',
                roomId: currentRoom,
                payload: {
                    userId: currentUser.id,
                    username: currentUser.username,
                    targetUserId: userId,
                    accepted: true,
                    callType: callType
                }
            });

            showToast({
                type: 'success',
                title: 'üìû Call Accepted',
                message: 'Connecting to the video call...',
                duration: 3000
            });
        }

        function declineCall(userId, username, callType = 'video') {
            // Send decline message
            sendWebSocketMessage({
                type: 'call_answer',
                roomId: currentRoom,
                payload: {
                    userId: currentUser.id,
                    username: currentUser.username,
                    targetUserId: userId,
                    accepted: false,
                    callType: callType
                }
            });

            showToast({
                type: 'info',
                title: 'üìû Call Declined',
                message: 'You declined the call',
                duration: 3000
            });
        }

        // Toast Notification Functions
        function showToast(options) {
            const {
                type = 'info',
                title,
                message,
                actions = [],
                duration = 5000,
                persistent = false
            } = options;

            const toast = document.createElement('div');
            toast.className = `toast ${type}`;

            const toastId = 'toast_' + Date.now();
            toast.id = toastId;

            let actionsHtml = '';
            if (actions.length > 0) {
                actionsHtml = '<div class="toast-actions">';
                actions.forEach(action => {
                    actionsHtml += `<button class="toast-btn ${action.class}" onclick="${action.onclick}">${action.text}</button>`;
                });
                actionsHtml += '</div>';
            }

            toast.innerHTML = `
                <button class="toast-close" onclick="closeToast('${toastId}')">&times;</button>
                <div class="toast-header">${title}</div>
                <div class="toast-body">${message}</div>
                ${actionsHtml}
            `;

            toastContainer.appendChild(toast);

            // Auto-remove toast unless persistent
            if (!persistent && duration > 0) {
                setTimeout(() => {
                    closeToast(toastId);
                }, duration);
            }

            return toastId;
        }

        function closeToast(toastId) {
            const toast = document.getElementById(toastId);
            if (toast) {
                toast.style.animation = 'slideOut 0.3s ease-out';
                setTimeout(() => {
                    if (toast.parentNode) {
                        toast.parentNode.removeChild(toast);
                    }
                }, 300);
            }
        }

        function showCallInviteToast(callerUsername, callerId, callType = 'video') {
            const callIcon = callType === 'audio' ? 'üìû' : 'üìπ';
            const actualToastId = showToast({
                type: 'call-invite',
                title: `${callIcon} ${callType.charAt(0).toUpperCase() + callType.slice(1)} Call Invitation`,
                message: `${callerUsername} is inviting you to a ${callType} call`,
                actions: [
                    {
                        text: 'Accept',
                        class: 'accept',
                        onclick: `acceptCallFromToast('${callerId}', '${actualToastId}', '${callType}')`
                    },
                    {
                        text: 'Decline',
                        class: 'decline',
                        onclick: `declineCallFromToast('${callerId}', '${actualToastId}')`
                    }
                ],
                persistent: true
            });

            // Auto-decline after 30 seconds
            setTimeout(() => {
                const toast = document.getElementById(actualToastId);
                if (toast) {
                    declineCallFromToast(callerId, actualToastId);
                }
            }, 30000);

            return actualToastId;
        }

        // Video Call Participant Management
        function addParticipantVideo(userId, username, stream) {
            // Remove existing participant video if any
            removeParticipantVideo(userId);

            const participantDiv = document.createElement('div');
            participantDiv.className = 'participant-video';
            participantDiv.id = `participant-${userId}`;

            const video = document.createElement('video');
            video.autoplay = true;
            video.srcObject = stream;

            const label = document.createElement('div');
            label.className = 'user-label';
            label.textContent = username;

            participantDiv.appendChild(video);
            participantDiv.appendChild(label);

            // Make participant video clickable to switch to main view
            participantDiv.addEventListener('click', () => {
                switchToMainVideo(userId, username, stream);
            });

            participantVideos.appendChild(participantDiv);

            // Store the stream for later use
            remoteStreams.set(userId, { stream, username });
        }

        function removeParticipantVideo(userId) {
            const existingVideo = document.getElementById(`participant-${userId}`);
            if (existingVideo) {
                existingVideo.remove();
            }
            remoteStreams.delete(userId);
        }

        function switchToMainVideo(userId, username, stream) {
            // Get current main video info
            const currentMainVideo = mainVideo.querySelector('video');
            const currentLabel = mainVideo.querySelector('.user-label');
            const currentStream = currentMainVideo.srcObject;
            const currentUsername = currentLabel.textContent;

            // Switch the main video
            currentMainVideo.srcObject = stream;
            currentLabel.textContent = username;

            // If the current main video was not "You", add it to participants
            if (currentUsername !== 'You' && currentStream) {
                // Find the user ID for the current main video
                for (const [uid, data] of remoteStreams.entries()) {
                    if (data.stream === currentStream) {
                        addParticipantVideo(uid, currentUsername, currentStream);
                        break;
                    }
                }
            }

            // Remove the clicked participant from sidebar
            removeParticipantVideo(userId);
        }

        function clearAllParticipants() {
            participantVideos.innerHTML = '';
            remoteStreams.clear();
        }

        // WebSocket Connection Functions
        function generateUserId() {
            return 'user_' + Math.random().toString(36).substr(2, 9);
        }

        function connect() {
            const username = usernameInput.value.trim();
            if (!username) {
                alert('Please enter a username');
                return;
            }

            currentUser = {
                id: generateUserId(),
                username: username
            };

            const wsUrl = `ws://localhost:8080/ws?user_id=${currentUser.id}&username=${encodeURIComponent(username)}`;

            try {
                ws = new WebSocket(wsUrl);
                ws.onopen = onWebSocketOpen;
                ws.onmessage = onWebSocketMessage;
                ws.onclose = onWebSocketClose;
                ws.onerror = onWebSocketError;
                updateConnectionStatus('Connecting...', 'disconnected');
            } catch (error) {
                console.error('Failed to create WebSocket connection:', error);
                updateConnectionStatus('Connection failed', 'disconnected');
            }
        }

        function onWebSocketOpen() {
            console.log('WebSocket connected');
            updateConnectionStatus('Connected', 'connected');
            userSetup.style.display = 'none';
            roomsSection.style.display = 'block';
            messageInput.disabled = false;
            sendBtn.disabled = false;
            reconnectAttempts = 0;

            joinRoom('public:lobby');
            addSystemMessage('Connected to chat server - All media features available!');

            // Start periodic user list updates
            if (window.userListInterval) {
                clearInterval(window.userListInterval);
            }
            window.userListInterval = setInterval(updateUserList, 30000); // Update every 30 seconds
        }

        function onWebSocketMessage(event) {
            try {
                const message = JSON.parse(event.data);
                handleMessage(message);
            } catch (error) {
                console.error('Failed to parse message:', error);
            }
        }

        function onWebSocketClose(event) {
            console.log('WebSocket closed:', event.code, event.reason);
            updateConnectionStatus('Disconnected', 'disconnected');
            messageInput.disabled = true;
            sendBtn.disabled = true;

            if (reconnectAttempts < maxReconnectAttempts) {
                reconnectAttempts++;
                addSystemMessage(`Connection lost. Reconnecting... (${reconnectAttempts}/${maxReconnectAttempts})`);
                setTimeout(() => {
                    if (currentUser) {
                        connect();
                    }
                }, 2000 * reconnectAttempts);
            } else {
                addSystemMessage('Connection lost. Please refresh the page to reconnect.');
                userSetup.style.display = 'block';
                roomsSection.style.display = 'none';
            }
        }

        function onWebSocketError(error) {
            console.error('WebSocket error:', error);
            updateConnectionStatus('Connection error', 'disconnected');
        }

        function updateConnectionStatus(text, status) {
            connectionStatus.textContent = text;
            connectionStatus.className = `connection-status ${status}`;
        }

        // Message Handling
        function handleMessage(message) {
            console.log('Received message:', message);

            switch (message.type) {
                case 'message':
                    addChatMessage(message);
                    break;
                case 'thread_reply':
                    addChatMessage(message, true);
                    break;
                case 'user_joined':
                    addSystemMessage(`${message.payload.username} joined the room`);
                    updateUserList();
                    break;
                case 'user_left':
                    addSystemMessage(`${message.payload.username} left the room`);
                    updateUserList();
                    break;
                case 'typing_start':
                    showTypingIndicator(message.payload.username);
                    break;
                case 'typing_stop':
                    hideTypingIndicator(message.payload.username);
                    break;
                case 'file_share':
                    addFileMessage(message);
                    break;
                case 'media_share':
                    addMediaMessage(message);
                    break;
                case 'call_invite':
                    handleCallInvite(message);
                    break;
                case 'call_answer':
                    handleCallAnswer(message);
                    break;
                case 'call_end':
                    handleCallEnd(message);
                    break;
                case 'webrtc_signal':
                    handleWebRTCSignal(message);
                    break;
                case 'ack':
                    console.log('Message acknowledged:', message.payload);
                    break;
                case 'error':
                    addSystemMessage(`Error: ${message.payload.message}`, 'error');
                    break;
                default:
                    console.log('Unknown message type:', message.type);
            }
        }

        // Room Management
        function joinRoom(roomId, element = null) {
            if (!ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }

            document.querySelectorAll('.room-btn').forEach(btn => {
                btn.classList.remove('active');
            });
            if (element) {
                element.classList.add('active');
            } else {
                const roomBtn = document.querySelector(`[onclick*="${roomId}"]`);
                if (roomBtn) {
                    roomBtn.classList.add('active');
                }
            }

            if (currentRoom && currentRoom !== roomId) {
                sendWebSocketMessage({
                    type: 'leave_room',
                    roomId: currentRoom
                });
            }

            currentRoom = roomId;

            sendWebSocketMessage({
                type: 'join_room',
                roomId: roomId
            });

            messagesContainer.innerHTML = '';
            addSystemMessage(`Joined room: ${roomId}`);

            // Update user list
            updateUserList();
        }

        // Update user list for current room
        function updateUserList() {
            if (!currentRoom) return;

            fetch(`/api/rooms/${currentRoom}/members`)
                .then(response => response.json())
                .then(data => {
                    const onlineUsersDiv = document.getElementById('onlineUsers');
                    onlineUsersDiv.innerHTML = '';

                    if (data.members && data.members.length > 0) {
                        data.members.forEach(member => {
                            const userDiv = document.createElement('div');
                            userDiv.className = `user-item ${member.userId === currentUser.id ? 'self' : ''}`;

                            // Display actual username instead of placeholder User_*
                            const displayName = member.username || member.userId;

                            userDiv.innerHTML = `
                                <div class="user-status"></div>
                                <span>${displayName} ${member.userId === currentUser.id ? '(You)' : ''}</span>
                            `;

                            onlineUsersDiv.appendChild(userDiv);
                        });
                    } else {
                        onlineUsersDiv.innerHTML = '<div style="padding: 0.5rem; color: #6b7280; font-size: 0.875rem;">No users online</div>';
                    }
                })
                .catch(error => {
                    console.error('Error fetching users:', error);
                    // Show current user at least
                    const onlineUsersDiv = document.getElementById('onlineUsers');
                    onlineUsersDiv.innerHTML = `
                        <div class="user-item self">
                            <div class="user-status"></div>
                            <span>${currentUser.username} (You)</span>
                        </div>
                    `;
                });
        }

        // Message Sending
        function sendMessage() {
            const content = messageInput.value.trim();

            // Send files if any are pending
            if (pendingFiles.length > 0) {
                sendFiles();
                return;
            }

            if (!content || !ws || ws.readyState !== WebSocket.OPEN) {
                return;
            }

            sendWebSocketMessage({
                type: 'message',
                roomId: currentRoom,
                payload: {
                    content: content,
                    userId: currentUser.id,
                    username: currentUser.username,
                    messageId: generateMessageId()
                }
            });

            messageInput.value = '';
            stopTyping();
        }

        function sendWebSocketMessage(message) {
            if (ws && ws.readyState === WebSocket.OPEN) {
                ws.send(JSON.stringify(message));
            }
        }

        // File Handling
        function handleFileSelection(event) {
            const files = Array.from(event.target.files);
            files.forEach(file => {
                pendingFiles.push(file);
                addFilePreview(file);
            });
            event.target.value = ''; // Reset input
        }

        function addFilePreview(file) {
            const previewItem = document.createElement('div');
            previewItem.className = 'preview-item';

            const fileInfo = document.createElement('span');
            fileInfo.textContent = `${file.name} (${formatFileSize(file.size)})`;

            const removeBtn = document.createElement('button');
            removeBtn.className = 'remove-btn';
            removeBtn.textContent = '√ó';
            removeBtn.onclick = () => {
                const index = pendingFiles.indexOf(file);
                if (index > -1) {
                    pendingFiles.splice(index, 1);
                    previewItem.remove();
                }
            };

            previewItem.appendChild(fileInfo);
            previewItem.appendChild(removeBtn);
            previewContainer.appendChild(previewItem);
        }

        function sendFiles() {
            if (pendingFiles.length === 0) return;

            // Use HTTP upload instead of WebSocket for large files
            const formData = new FormData();

            pendingFiles.forEach(file => {
                formData.append('files', file);
            });

            formData.append('roomId', currentRoom);

            // Upload files via HTTP
            fetch('/api/upload', {
                method: 'POST',
                headers: {
                    'X-User-ID': currentUser.id,
                    'X-Username': currentUser.username
                },
                body: formData
            })
                .then(response => response.json())
                .then(data => {
                    if (data.status === 'success') {
                        console.log('Files uploaded successfully:', data.files);

                        // Add a text message if there's content
                        const content = messageInput.value.trim();
                        if (content) {
                            sendWebSocketMessage({
                                type: 'message',
                                roomId: currentRoom,
                                payload: {
                                    content: content,
                                    userId: currentUser.id,
                                    username: currentUser.username,
                                    messageId: generateMessageId()
                                }
                            });
                            messageInput.value = '';
                        }
                    } else {
                        addSystemMessage('Failed to upload files', 'error');
                    }
                })
                .catch(error => {
                    console.error('File upload error:', error);
                    addSystemMessage('File upload failed', 'error');
                });

            // Clear pending files and previews
            pendingFiles = [];
            previewContainer.innerHTML = '';
        }

        // Photo Capture
        function capturePhoto() {
            document.getElementById('cameraInput').click();
        }

        // Audio Recording
        async function toggleAudioRecording() {
            const btn = document.getElementById('audioRecordBtn');

            if (!isRecordingAudio) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
                    audioRecorder = new MediaRecorder(stream);
                    recordedChunks = [];

                    audioRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };

                    audioRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'audio/webm' });
                        const file = new File([blob], `audio_${Date.now()}.webm`, { type: 'audio/webm' });
                        pendingFiles.push(file);
                        addFilePreview(file);

                        // Also send as media_share message directly via WebSocket for better compatibility
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const base64data = reader.result.split(',')[1];

                            // Send media via WebSocket
                            sendWebSocketMessage({
                                type: 'media_share',
                                roomId: currentRoom,
                                payload: {
                                    mediaType: 'audio',
                                    mediaData: base64data,
                                    duration: 0, // We don't know the duration
                                    userId: currentUser.id,
                                    username: currentUser.username,
                                    messageId: generateMessageId()
                                }
                            });
                        };
                        reader.readAsDataURL(blob);

                        // Stop all tracks
                        stream.getTracks().forEach(track => track.stop());
                    };

                    audioRecorder.start();
                    isRecordingAudio = true;
                    btn.textContent = '‚èπÔ∏è Stop';
                    btn.classList.add('btn-danger');
                } catch (error) {
                    console.error('Error accessing microphone:', error);
                    alert('Could not access microphone');
                }
            } else {
                audioRecorder.stop();
                isRecordingAudio = false;
                btn.textContent = 'üé§ Audio';
                btn.classList.remove('btn-danger');
            }
        }

        // Video Recording
        async function toggleVideoRecording() {
            const btn = document.getElementById('videoRecordBtn');

            if (!isRecordingVideo) {
                try {
                    const stream = await navigator.mediaDevices.getUserMedia({
                        video: true,
                        audio: true
                    });

                    const preview = document.getElementById('cameraPreview');
                    preview.srcObject = stream;
                    preview.style.display = 'block';

                    videoRecorder = new MediaRecorder(stream);
                    recordedChunks = [];

                    videoRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };

                    videoRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const file = new File([blob], `video_${Date.now()}.webm`, { type: 'video/webm' });
                        pendingFiles.push(file);
                        addFilePreview(file);

                        // Also send as media_share message directly via WebSocket for better compatibility
                        const reader = new FileReader();
                        reader.onloadend = () => {
                            const base64data = reader.result.split(',')[1];

                            // Send media via WebSocket
                            sendWebSocketMessage({
                                type: 'media_share',
                                roomId: currentRoom,
                                payload: {
                                    mediaType: 'video',
                                    mediaData: base64data,
                                    duration: 0, // We don't know the duration
                                    userId: currentUser.id,
                                    username: currentUser.username,
                                    messageId: generateMessageId()
                                }
                            });
                        };
                        reader.readAsDataURL(blob);

                        preview.style.display = 'none';
                        stream.getTracks().forEach(track => track.stop());
                    };

                    videoRecorder.start();
                    isRecordingVideo = true;
                    btn.textContent = '‚èπÔ∏è Stop';
                    btn.classList.add('btn-danger');
                } catch (error) {
                    console.error('Error accessing camera:', error);
                    alert('Could not access camera');
                }
            } else {
                videoRecorder.stop();
                isRecordingVideo = false;
                btn.textContent = 'üìπ Video';
                btn.classList.remove('btn-danger');
            }
        }

        // Location Sharing
        function shareLocation() {
            if (navigator.geolocation) {
                navigator.geolocation.getCurrentPosition(
                    (position) => {
                        const { latitude, longitude } = position.coords;
                        sendWebSocketMessage({
                            type: 'message',
                            roomId: currentRoom,
                            payload: {
                                content: `üìç Location: https://maps.google.com/?q=${latitude},${longitude}`,
                                userId: currentUser.id,
                                username: currentUser.username,
                                messageId: generateMessageId(),
                                isLocation: true,
                                latitude: latitude,
                                longitude: longitude
                            }
                        });
                    },
                    (error) => {
                        console.error('Geolocation error:', error);
                        alert('Could not get your location');
                    }
                );
            } else {
                alert('Geolocation is not supported by this browser');
            }
        }

        // Video Calling Functions
        async function startAudioCall() {
            if (isInCall) {
                endCall();
                return;
            }

            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: false,
                    audio: true
                });

                videoCallContainer.style.display = 'flex';
                isInCall = true;

                // Hide video elements for audio-only call
                const localVideo = document.getElementById('localVideo');
                if (localVideo) {
                    localVideo.style.display = 'none';
                }

                document.getElementById('audioCallBtn').textContent = 'üìû End Call';
                document.getElementById('audioCallBtn').classList.remove('btn-success');
                document.getElementById('audioCallBtn').classList.add('btn-danger');

                // Notify others in the room
                sendWebSocketMessage({
                    type: 'call_invite',
                    roomId: currentRoom,
                    payload: {
                        userId: currentUser.id,
                        username: currentUser.username,
                        callType: 'audio',
                        roomId: currentRoom
                    }
                });

                showToast({
                    type: 'success',
                    title: 'üìû Audio Call Started',
                    message: 'Audio call started. Others can join now.',
                    duration: 3000
                });
            } catch (error) {
                console.error('Error starting audio call:', error);
                showToast({
                    type: 'error',
                    title: 'Audio Call Error',
                    message: 'Could not access microphone',
                    duration: 5000
                });
            }
        }

        async function startVideoCall() {
            if (isInCall) {
                endCall();
                return;
            }

            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    video: true,
                    audio: true
                });

                const localVideo = document.getElementById('localVideo');
                if (localVideo) {
                    localVideo.srcObject = localStream;
                    localVideo.style.display = 'block';
                }
                videoCallContainer.style.display = 'flex';
                isInCall = true;

                document.getElementById('videoCallBtn').textContent = 'üìû End Call';
                document.getElementById('videoCallBtn').classList.remove('btn-success');
                document.getElementById('videoCallBtn').classList.add('btn-danger');

                // Notify others in the room
                sendWebSocketMessage({
                    type: 'call_invite',
                    roomId: currentRoom,
                    payload: {
                        userId: currentUser.id,
                        username: currentUser.username,
                        callType: 'video',
                        roomId: currentRoom
                    }
                });

                showToast({
                    type: 'success',
                    title: 'üìπ Video Call Started',
                    message: 'Video call started. Others can join now.',
                    duration: 3000
                });
            } catch (error) {
                console.error('Error starting video call:', error);
                showToast({
                    type: 'error',
                    title: 'Video Call Error',
                    message: 'Could not access camera/microphone',
                    duration: 5000
                });
            }
        }

        function endCall() {
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
                localStream = null;
            }

            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;
            }

            // Close all peer connections
            peerConnections.forEach(pc => pc.close());
            peerConnections.clear();

            // Clear all participants
            clearAllParticipants();

            videoCallContainer.style.display = 'none';
            isInCall = false;
            isMuted = false;
            isCameraOff = false;
            isScreenSharing = false;

            // Reset both call buttons
            const audioCallBtn = document.getElementById('audioCallBtn');
            const videoCallBtn = document.getElementById('videoCallBtn');

            audioCallBtn.textContent = 'üìû Audio Call';
            audioCallBtn.classList.remove('btn-danger');
            audioCallBtn.classList.add('btn-success');

            videoCallBtn.textContent = 'üìπ Video Call';
            videoCallBtn.classList.remove('btn-danger');
            videoCallBtn.classList.add('btn-success');

            document.getElementById('muteBtn').textContent = 'üîá Mute';
            document.getElementById('cameraBtn').textContent = 'üìπ Camera';
            document.getElementById('shareBtn').textContent = 'üñ•Ô∏è Share';
            document.getElementById('screenShareIndicator').style.display = 'none';

            // Reset main video to local
            const mainVideoEl = mainVideo.querySelector('video');
            const mainLabel = mainVideo.querySelector('.user-label');
            mainVideoEl.srcObject = null;
            mainLabel.textContent = 'You';

            // Notify others that call ended
            sendWebSocketMessage({
                type: 'call_end',
                roomId: currentRoom,
                payload: {
                    userId: currentUser.id,
                    username: currentUser.username
                }
            });

            showToast({
                type: 'info',
                title: 'üìû Call Ended',
                message: 'Call has been ended',
                duration: 3000
            });
        }

        function toggleMute() {
            if (localStream) {
                const audioTrack = localStream.getAudioTracks()[0];
                if (audioTrack) {
                    audioTrack.enabled = !audioTrack.enabled;
                    isMuted = !audioTrack.enabled;
                    document.getElementById('muteBtn').textContent = isMuted ? 'üîä Unmute' : 'üîá Mute';
                }
            }
        }

        function toggleCamera() {
            if (localStream) {
                const videoTrack = localStream.getVideoTracks()[0];
                if (videoTrack) {
                    videoTrack.enabled = !videoTrack.enabled;
                    isCameraOff = !videoTrack.enabled;
                    document.getElementById('cameraBtn').textContent = isCameraOff ? 'üìπ Camera On' : 'üìπ Camera Off';
                }
            }
        }

        async function toggleScreenShare() {
            if (!isScreenSharing) {
                try {
                    screenStream = await navigator.mediaDevices.getDisplayMedia({
                        video: true,
                        audio: true
                    });

                    // Replace video track for all peer connections
                    if (localStream && isInCall) {
                        const videoTrack = screenStream.getVideoTracks()[0];

                        // Update all peer connections with screen share
                        for (const [userId, pc] of peerConnections) {
                            const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                            if (sender) {
                                await sender.replaceTrack(videoTrack);
                            }
                        }

                        // Update local video in main area
                        const localVideo = document.getElementById('localVideo');
                        if (localVideo) {
                            localVideo.srcObject = screenStream;
                        }

                        // Update user label to indicate screen sharing
                        const mainVideoLabel = document.querySelector('.main-video .user-label');
                        if (mainVideoLabel) {
                            mainVideoLabel.textContent = 'You (Sharing Screen)';
                        }
                    }

                    isScreenSharing = true;
                    document.getElementById('shareBtn').textContent = 'üñ•Ô∏è Stop Share';
                    document.getElementById('screenShareIndicator').style.display = 'block';

                    // Send screen share start notification
                    sendWebSocketMessage({
                        type: 'screen_share',
                        roomId: currentRoom,
                        payload: {
                            userId: currentUser.id,
                            username: currentUser.username,
                            isSharing: true,
                            streamId: Date.now().toString()
                        }
                    });

                    // Capture a screenshot to share
                    setTimeout(() => {
                        const videoElem = document.createElement('video');
                        videoElem.srcObject = screenStream;
                        videoElem.onloadedmetadata = () => {
                            videoElem.play();

                            // Create a canvas to capture the screenshot
                            const canvas = document.createElement('canvas');
                            canvas.width = videoElem.videoWidth;
                            canvas.height = videoElem.videoHeight;
                            const ctx = canvas.getContext('2d');
                            ctx.drawImage(videoElem, 0, 0, canvas.width, canvas.height);

                            // Convert to base64 and send
                            const base64data = canvas.toDataURL('image/png').split(',')[1];
                            sendWebSocketMessage({
                                type: 'media_share',
                                roomId: currentRoom,
                                payload: {
                                    mediaType: 'screen',
                                    mediaData: base64data,
                                    userId: currentUser.id,
                                    username: currentUser.username,
                                    messageId: generateMessageId()
                                }
                            });
                        };
                    }, 1000);

                    // Auto-stop when user ends screen share from browser UI
                    screenStream.getVideoTracks()[0].addEventListener('ended', () => {
                        stopScreenShare();
                    });

                } catch (error) {
                    console.error('Error sharing screen:', error);
                    showToast({
                        type: 'error',
                        title: 'Screen Share Error',
                        message: 'Failed to start screen sharing',
                        duration: 5000
                    });
                }
            } else {
                stopScreenShare();
            }
        }

        async function stopScreenShare() {
            if (screenStream) {
                screenStream.getTracks().forEach(track => track.stop());
                screenStream = null;

                // Send screen share stop notification
                sendWebSocketMessage({
                    type: 'screen_share',
                    roomId: currentRoom,
                    payload: {
                        userId: currentUser.id,
                        username: currentUser.username,
                        isSharing: false
                    }
                });
            }

            // Switch back to camera for all peer connections
            if (isInCall && localStream) {
                const videoTrack = localStream.getVideoTracks()[0];

                // Update all peer connections to use camera again
                for (const [userId, pc] of peerConnections) {
                    const sender = pc.getSenders().find(s => s.track && s.track.kind === 'video');
                    if (sender && videoTrack) {
                        await sender.replaceTrack(videoTrack);
                    }
                }

                // Update local video in main area back to camera
                const localVideo = document.getElementById('localVideo');
                if (localVideo) {
                    localVideo.srcObject = localStream;
                }

                // Reset user label
                const mainVideoLabel = document.querySelector('.main-video .user-label');
                if (mainVideoLabel) {
                    mainVideoLabel.textContent = 'You';
                }
            }

            isScreenSharing = false;
            document.getElementById('shareBtn').textContent = 'üñ•Ô∏è Share';
            document.getElementById('screenShareIndicator').style.display = 'none';
        }

        // Call Recording
        function toggleRecording() {
            const btn = document.getElementById('recordBtn');
            const indicator = document.getElementById('recordingIndicator');

            if (!isRecordingCall) {
                if (!isInCall) {
                    showToast({
                        type: 'warning',
                        title: 'Recording Not Available',
                        message: 'Start a video call first to record',
                        duration: 3000
                    });
                    return;
                } try {
                    const localVideo = document.getElementById('localVideo');
                    const stream = localVideo ? localVideo.srcObject : localStream;
                    mediaRecorder = new MediaRecorder(stream);
                    recordedChunks = [];

                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const a = document.createElement('a');
                        a.href = url;
                        a.download = `call_recording_${Date.now()}.webm`;
                        a.click();
                        URL.revokeObjectURL(url);
                    };

                    mediaRecorder.start();
                    isRecordingCall = true;
                    btn.textContent = '‚èπÔ∏è Stop Recording';
                    indicator.style.display = 'block';
                } catch (error) {
                    console.error('Error starting recording:', error);
                    alert('Could not start recording');
                }
            } else {
                mediaRecorder.stop();
                isRecordingCall = false;
                btn.textContent = '‚è∫Ô∏è Record';
                indicator.style.display = 'none';
            }
        }

        // Toast-based call handling (single implementation)
        function acceptCallFromToast(callerId, toastId, callType = 'video') {
            closeToast(toastId);

            // Get call type from the toast content if possible
            if (toastId) {
                const toast = document.getElementById(toastId);
                if (toast) {
                    const titleEl = toast.querySelector('.toast-header');
                    if (titleEl && titleEl.textContent.includes('Audio')) {
                        callType = 'audio';
                    }
                }
            }

            // Send call answer
            sendWebSocketMessage({
                type: 'call_answer',
                roomId: currentRoom,
                payload: {
                    userId: currentUser.id,
                    username: currentUser.username,
                    callId: callerId,
                    accepted: true,
                    callType: callType
                }
            });

            // Start own call based on call type
            if (callType === 'audio') {
                startAudioCall();
                showToast({
                    type: 'info',
                    title: 'üìû Joining Call',
                    message: 'Connecting to the audio call...',
                    duration: 3000
                });
            } else {
                startVideoCall();
                showToast({
                    type: 'info',
                    title: 'üìπ Joining Call',
                    message: 'Connecting to the video call...',
                    duration: 3000
                });
            }
        }

        function declineCallFromToast(callerId, toastId) {
            closeToast(toastId);

            // Get call type from the toast content if possible
            let callType = 'video';
            if (toastId) {
                const toast = document.getElementById(toastId);
                if (toast) {
                    const titleEl = toast.querySelector('.toast-header');
                    if (titleEl && titleEl.textContent.includes('Audio')) {
                        callType = 'audio';
                    }
                }
            }

            // Send call decline
            sendWebSocketMessage({
                type: 'call_answer',
                roomId: currentRoom,
                payload: {
                    userId: currentUser.id,
                    username: currentUser.username,
                    callId: callerId,
                    accepted: false,
                    callType: callType
                }
            });

            showToast({
                type: 'info',
                title: 'üìû Call Declined',
                message: 'You declined the call',
                duration: 3000
            });
        }

        // WebRTC Signal Handlers
        function handleCallInvite(message) {
            // Don't show invitation to the person who started the call
            if (message.payload.userId === currentUser.id) {
                console.log('Ignoring own call invite');
                return;
            }

            const callType = message.payload.callType || 'video';
            const callIcon = callType === 'audio' ? 'üìû' : 'üìπ';

            // Show system message in chat
            addSystemMessage(`${callIcon} ${message.payload.username} started a ${callType} call`);

            // Show call invitation
            showCallInviteToast(
                message.payload.username,
                message.payload.userId,
                callType
            );
        }

        function handleCallAnswer(message) {
            if (message.payload.accepted) {
                showToast({
                    type: 'success',
                    title: 'üìπ Call Accepted',
                    message: `${message.payload.username} joined the call`,
                    duration: 3000
                });
                // TODO: Set up WebRTC peer connection
            } else {
                addSystemMessage(`üìû ${message.payload.username} declined the call`);
                showToast({
                    type: 'warning',
                    title: 'üìû Call Declined',
                    message: `${message.payload.username} declined the call`,
                    duration: 3000
                });
            }
        }

        function handleCallEnd(message) {
            addSystemMessage(`üìû ${message.payload.username} ended the call`);
            showToast({
                type: 'info',
                title: 'üìû Call Ended',
                message: `${message.payload.username} ended the call`,
                duration: 3000
            });
        }

        function handleWebRTCSignal(message) {
            // Handle WebRTC signaling - would implement full WebRTC logic
            console.log('WebRTC signal:', message);
        }

        // UI Message Functions
        function addChatMessage(message, isReply = false) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.payload.userId === currentUser.id ? 'own' : 'other'}`;

            const senderDiv = document.createElement('div');
            senderDiv.className = 'sender';
            senderDiv.textContent = message.payload.username;

            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';

            // Handle location messages
            if (message.payload.isLocation) {
                const locationLink = document.createElement('a');
                locationLink.href = `https://maps.google.com/?q=${message.payload.latitude},${message.payload.longitude}`;
                locationLink.target = '_blank';
                locationLink.textContent = message.payload.content;
                contentDiv.appendChild(locationLink);
            } else {
                contentDiv.textContent = message.payload.content;
            }

            const timeDiv = document.createElement('div');
            timeDiv.className = 'time';
            timeDiv.textContent = new Date(message.timestamp).toLocaleTimeString();

            messageDiv.appendChild(senderDiv);
            messageDiv.appendChild(contentDiv);
            messageDiv.appendChild(timeDiv);

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addFileMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.payload.userId === currentUser.id ? 'own' : 'other'}`;

            const senderDiv = document.createElement('div');
            senderDiv.className = 'sender';
            senderDiv.textContent = message.payload.username;

            const fileDiv = document.createElement('div');
            fileDiv.className = 'file-attachment';

            const fileIcon = getFileIcon(message.payload.fileType);
            const fileName = message.payload.fileName;
            const fileSize = formatFileSize(message.payload.fileSize);

            fileDiv.innerHTML = `${fileIcon} ${fileName} (${fileSize})`;
            fileDiv.onclick = () => downloadFile(message.payload);

            // Add media preview for images, videos, audio
            if (message.payload.fileType.startsWith('image/')) {
                const img = document.createElement('img');
                img.src = `data:${message.payload.fileType};base64,${message.payload.fileData}`;
                img.style.maxWidth = '200px';
                img.style.borderRadius = '5px';
                const mediaDiv = document.createElement('div');
                mediaDiv.className = 'media-preview';
                mediaDiv.appendChild(img);
                fileDiv.appendChild(mediaDiv);
            } else if (message.payload.fileType.startsWith('video/')) {
                const video = document.createElement('video');
                video.src = `data:${message.payload.fileType};base64,${message.payload.fileData}`;
                video.controls = true;
                video.style.maxWidth = '200px';
                const mediaDiv = document.createElement('div');
                mediaDiv.className = 'media-preview';
                mediaDiv.appendChild(video);
                fileDiv.appendChild(mediaDiv);
            } else if (message.payload.fileType.startsWith('audio/')) {
                const audio = document.createElement('audio');
                audio.src = `data:${message.payload.fileType};base64,${message.payload.fileData}`;
                audio.controls = true;
                const mediaDiv = document.createElement('div');
                mediaDiv.className = 'media-preview';
                mediaDiv.appendChild(audio);
                fileDiv.appendChild(mediaDiv);
            }

            const timeDiv = document.createElement('div');
            timeDiv.className = 'time';
            timeDiv.textContent = new Date(message.timestamp).toLocaleTimeString();

            messageDiv.appendChild(senderDiv);
            messageDiv.appendChild(fileDiv);
            messageDiv.appendChild(timeDiv);

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addMediaMessage(message) {
            const messageDiv = document.createElement('div');
            messageDiv.className = `message ${message.payload.userId === currentUser.id ? 'own' : 'other'}`;

            const senderDiv = document.createElement('div');
            senderDiv.className = 'sender';
            senderDiv.textContent = message.payload.username;

            const mediaDiv = document.createElement('div');
            mediaDiv.className = 'media-preview';

            // Handle different media types
            if (message.payload.mediaType === 'audio') {
                const audio = document.createElement('audio');
                audio.src = `data:audio/webm;base64,${message.payload.mediaData}`;
                audio.controls = true;
                mediaDiv.appendChild(audio);
            } else if (message.payload.mediaType === 'video') {
                const video = document.createElement('video');
                video.src = `data:video/webm;base64,${message.payload.mediaData}`;
                video.controls = true;
                video.style.maxWidth = '200px';
                mediaDiv.appendChild(video);
            } else if (message.payload.mediaType === 'screen' || message.payload.mediaType === 'screen_recording') {
                if (message.payload.mediaType === 'screen') {
                    const img = document.createElement('img');
                    img.src = `data:image/png;base64,${message.payload.mediaData}`;
                    img.style.maxWidth = '200px';
                    img.style.borderRadius = '5px';
                    mediaDiv.appendChild(img);
                } else {
                    const video = document.createElement('video');
                    video.src = `data:video/webm;base64,${message.payload.mediaData}`;
                    video.controls = true;
                    video.style.maxWidth = '200px';
                    mediaDiv.appendChild(video);
                }

                const label = document.createElement('div');
                label.textContent = message.payload.mediaType === 'screen' ? 'üñ•Ô∏è Screen Capture' : '‚è∫Ô∏è Screen Recording';
                label.style.fontSize = '0.8rem';
                label.style.color = '#6b7280';
                label.style.marginTop = '5px';
                mediaDiv.appendChild(label);
            }

            const timeDiv = document.createElement('div');
            timeDiv.className = 'time';
            timeDiv.textContent = new Date(message.timestamp).toLocaleTimeString();

            messageDiv.appendChild(senderDiv);
            messageDiv.appendChild(mediaDiv);
            messageDiv.appendChild(timeDiv);

            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        function addSystemMessage(text) {
            const messageDiv = document.createElement('div');
            messageDiv.className = 'message system';

            const contentDiv = document.createElement('div');
            contentDiv.className = 'content';
            contentDiv.textContent = text;

            messageDiv.appendChild(contentDiv);
            messagesContainer.appendChild(messageDiv);
            messagesContainer.scrollTop = messagesContainer.scrollHeight;
        }

        // Typing Indicators
        function showTypingIndicator(username) {
            typingIndicator.textContent = `${username} is typing...`;
        }

        function hideTypingIndicator(username) {
            if (typingIndicator.textContent.includes(username)) {
                typingIndicator.textContent = '';
            }
        }

        function startTyping() {
            if (!isTyping) {
                isTyping = true;
                sendWebSocketMessage({
                    type: 'typing',
                    roomId: currentRoom,
                    payload: {
                        userId: currentUser.id,
                        username: currentUser.username,
                        isTyping: true
                    }
                });
            }

            clearTimeout(typingTimeout);
            typingTimeout = setTimeout(stopTyping, 3000);
        }

        function stopTyping() {
            if (isTyping) {
                isTyping = false;
                sendWebSocketMessage({
                    type: 'typing',
                    roomId: currentRoom,
                    payload: {
                        userId: currentUser.id,
                        username: currentUser.username,
                        isTyping: false
                    }
                });
            }
            clearTimeout(typingTimeout);
        }

        // Utility Functions
        function generateMessageId() {
            return 'msg_' + Date.now() + '_' + Math.random().toString(36).substr(2, 9);
        }

        function formatFileSize(bytes) {
            if (bytes === 0) return '0 Bytes';
            const k = 1024;
            const sizes = ['Bytes', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        function getFileIcon(fileType) {
            if (fileType.startsWith('image/')) return 'üñºÔ∏è';
            if (fileType.startsWith('video/')) return 'üé¨';
            if (fileType.startsWith('audio/')) return 'üéµ';
            if (fileType.includes('pdf')) return 'üìÑ';
            if (fileType.includes('word') || fileType.includes('doc')) return 'üìù';
            if (fileType.includes('zip') || fileType.includes('rar')) return 'üì¶';
            return 'üìé';
        }

        function downloadFile(payload) {
            const link = document.createElement('a');
            link.href = `data:${payload.fileType};base64,${payload.fileData}`;
            link.download = payload.fileName;
            link.click();
        }

        // Screen sharing and recording functions
        async function shareScreen() {
            try {
                const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });

                // Convert to base64 and send as media message
                const canvas = document.createElement('canvas');
                const video = document.createElement('video');
                video.srcObject = stream;
                video.play();

                video.addEventListener('loadedmetadata', () => {
                    canvas.width = video.videoWidth;
                    canvas.height = video.videoHeight;
                    const ctx = canvas.getContext('2d');
                    ctx.drawImage(video, 0, 0);

                    canvas.toBlob((blob) => {
                        const reader = new FileReader();
                        reader.onload = () => {
                            const base64 = reader.result.split(',')[1];
                            sendWebSocketMessage({
                                type: 'media_share',
                                roomId: currentRoom,
                                payload: {
                                    mediaType: 'screen',
                                    mediaData: base64,
                                    duration: 0,
                                    userId: currentUser.id,
                                    username: currentUser.username,
                                    messageId: generateMessageId()
                                }
                            });
                        };
                        reader.readAsDataURL(blob);
                    });
                });

                // Stop tracks after capturing
                stream.getTracks().forEach(track => track.stop());

                showToast({
                    type: 'success',
                    title: 'üñ•Ô∏è Screen Shared',
                    message: 'Screen capture shared successfully',
                    duration: 3000
                });
            } catch (error) {
                console.error('Error sharing screen:', error);
                showToast({
                    type: 'error',
                    title: 'Screen Share Error',
                    message: 'Could not capture screen',
                    duration: 5000
                });
            }
        }

        async function recordScreen() {
            const btn = document.getElementById('screenRecordBtn');

            if (!mediaRecorder || mediaRecorder.state === 'inactive') {
                try {
                    const stream = await navigator.mediaDevices.getDisplayMedia({ video: true, audio: true });
                    recordedChunks = [];

                    mediaRecorder = new MediaRecorder(stream);
                    mediaRecorder.ondataavailable = (event) => {
                        if (event.data.size > 0) {
                            recordedChunks.push(event.data);
                        }
                    };

                    mediaRecorder.onstop = () => {
                        const blob = new Blob(recordedChunks, { type: 'video/webm' });
                        const reader = new FileReader();
                        reader.onload = () => {
                            const base64 = reader.result.split(',')[1];
                            sendWebSocketMessage({
                                type: 'media_share',
                                roomId: currentRoom,
                                payload: {
                                    mediaType: 'screen_recording',
                                    mediaData: base64,
                                    duration: Math.floor(Date.now() / 1000), // Simple duration
                                    userId: currentUser.id,
                                    username: currentUser.username,
                                    messageId: generateMessageId()
                                }
                            });
                        };
                        reader.readAsDataURL(blob);

                        showToast({
                            type: 'success',
                            title: '‚è∫Ô∏è Screen Recording Shared',
                            message: 'Screen recording shared successfully',
                            duration: 3000
                        });
                    };

                    mediaRecorder.start();
                    btn.textContent = '‚èπÔ∏è Stop Recording';
                    btn.classList.remove('btn-warning');
                    btn.classList.add('btn-danger');

                    showToast({
                        type: 'info',
                        title: '‚è∫Ô∏è Recording Started',
                        message: 'Screen recording started',
                        duration: 3000
                    });
                } catch (error) {
                    console.error('Error starting screen recording:', error);
                    showToast({
                        type: 'error',
                        title: 'Recording Error',
                        message: 'Could not start screen recording',
                        duration: 5000
                    });
                }
            } else {
                mediaRecorder.stop();
                btn.textContent = '‚è∫Ô∏è Record Screen';
                btn.classList.remove('btn-danger');
                btn.classList.add('btn-warning');
            }
        }

        // Event Listeners
        messageInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                sendMessage();
            } else {
                startTyping();
            }
        });

        usernameInput.addEventListener('keypress', (e) => {
            if (e.key === 'Enter') {
                connect();
            }
        });

        // Initialize
        console.log('Enhanced WebSocket Chat initialized with full media support!');
    </script>
</body>

</html>
